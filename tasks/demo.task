# demo.task
# --------------------------------------------------------
# Mario-style movement demo that keeps a sprite responsive
# with keyboard polling and smooth frame pacing.
# --------------------------------------------------------

RUN _CLEAR
RUN _TERM_RESOLUTION 640 360

PRINT "\nRetro platforming demo"
PRINT "\nUse LEFT/RIGHT (or A/D) to run, SPACE/UP to jump, ESC to exit."
PRINT "\n" 

# Player and physics constants
SET $SPRITE = "./tasks/assets/char_1_1.png"
SET $SPRITE_W = 48
SET $SPRITE_H = 48
SET $X = 120
SET $Y = 260
SET $LAST_X = $X
SET $LAST_Y = $Y
SET $FACING = 1
SET $VX = 0
SET $VY = 0
SET $SPEED = 180
SET $JUMP = 360
SET $GRAVITY = 900
SET $GROUND = 276
RUN _CALC $GROUND + $SPRITE_H TO $GROUND_LINE
RUN _CALC $GROUND_LINE + 12 TO $GROUND_LINE2
SET $RUNNING = 1
SET $DT = 16.0

RUN _TIMER --start
RUN _TIMER --reset

# Draw the static ground once to avoid repainting the full width each frame
RUN _RECT -x 0 -y $GROUND_LINE -width 640 -height 12 -color 24 -fill on
RUN _RECT -x 0 -y $GROUND_LINE2 -width 640 -height 12 -color 18 -fill on

WHILE ($RUNNING==1):
  RUN _TIMER --get TO $DT
  RUN _TIMER --reset

  # Input state via _TERM_KEYBOARD bitfield
  RUN _TERM_KEYBOARD --state TO $INPUT_STATE
  RUN _CALC fmod($INPUT_STATE, 2) TO $LEFT_HELD
  RUN _CALC fmod(floor($INPUT_STATE/2), 2) TO $RIGHT_HELD
  RUN _CALC fmod(floor($INPUT_STATE/4), 2) TO $JUMP_HELD
  RUN _CALC fmod(floor($INPUT_STATE/32), 2) TO $EXIT_HELD

  IF ($EXIT_HELD==1):
    SET $RUNNING = 0
  END

  SET $LAST_X = $X
  SET $LAST_Y = $Y

  IF ($JUMP_HELD==1 AND $Y >= $GROUND):
    RUN _CALC 0 - $JUMP TO $VY
  END

  SET $VX = 0
  IF ($LEFT_HELD==1):
    RUN _CALC 0 - $SPEED TO $VX
    SET $FACING = -1
  END
  IF ($RIGHT_HELD==1):
    RUN _CALC $SPEED TO $VX
    SET $FACING = 1
  END

  RUN _CALC $VY + $GRAVITY * ($DT/1000) TO $VY

  RUN _CALC $X + $VX * ($DT/1000) TO $X
  RUN _CALC $Y + $VY * ($DT/1000) TO $Y

  IF ($X < 0):
    SET $X = 0
  END
  RUN _CALC 640 - 48 TO $MAX_X
  IF ($X > $MAX_X):
    SET $X = $MAX_X
  END
  IF ($Y > $GROUND):
    SET $Y = $GROUND
    SET $VY = 0
  END

  # Clean only the sprite footprint and repaint the small region it occupied
  RUN _CALC fmax(0, $LAST_X - 4) TO $CLEAN_X
  RUN _CALC fmax(0, $LAST_Y - 4) TO $CLEAN_Y
  RUN _CALC $SPRITE_W + 8 TO $CLEAN_W
  RUN _CALC $CLEAN_Y + $SPRITE_H + 8 TO $CLEAN_BOTTOM

  # Sky above the first ground stripe
  IF ($CLEAN_Y < $GROUND_LINE):
    RUN _CALC fmin($GROUND_LINE, $CLEAN_BOTTOM) - $CLEAN_Y TO $SKY_H
    IF ($SKY_H > 0):
      RUN _RECT -x $CLEAN_X -y $CLEAN_Y -width $CLEAN_W -height $SKY_H -color 0 -fill on
    END
  END

  # Upper ground stripe (color 24)
  IF ($CLEAN_BOTTOM > $GROUND_LINE):
    RUN _CALC fmax($CLEAN_Y, $GROUND_LINE) TO $GROUND1_Y
    RUN _CALC fmin($GROUND_LINE2, $CLEAN_BOTTOM) - $GROUND1_Y TO $GROUND1_H
    IF ($GROUND1_H > 0):
      RUN _RECT -x $CLEAN_X -y $GROUND1_Y -width $CLEAN_W -height $GROUND1_H -color 24 -fill on
    END
  END

  # Lower ground stripe (color 18)
  IF ($CLEAN_BOTTOM > $GROUND_LINE2):
    RUN _CALC fmax($CLEAN_Y, $GROUND_LINE2) TO $GROUND2_Y
    RUN _CALC $CLEAN_BOTTOM - $GROUND2_Y TO $GROUND2_H
    IF ($GROUND2_H > 0):
      RUN _RECT -x $CLEAN_X -y $GROUND2_Y -width $CLEAN_W -height $GROUND2_H -color 18 -fill on
    END
  END

  # Rotate while airborne and mirror based on direction
  SET $ROTATE = 0
  IF ($VY < -30):
    SET $ROTATE = 90
  END
  IF ($VY > 60):
    SET $ROTATE = 270
  END

  IF ($FACING < 0):
    RUN _TERM_SPRITE -x $X -y $Y -file $SPRITE -mirrorX -rotate $ROTATE
  ELSE:
    RUN _TERM_SPRITE -x $X -y $Y -file $SPRITE -rotate $ROTATE
  END

  RUN _TERM_RENDER

  # Frame pacing for smooth motion
  RUN _CALC 1000/60 TO $FRAME_MS
  RUN _CALC $FRAME_MS - $DT TO $SLEEP
  RUN _CALC ceil($SLEEP) TO $SLEEP
  IF ($SLEEP > 0):
    RUN _WAIT $SLEEP
  END
END

RUN _TERM_CLEAN -x 0 -y 0 -width 640 -height 360
RUN _TERM_RESOLUTION 640 360
