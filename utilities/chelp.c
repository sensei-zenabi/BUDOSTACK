#include <stdio.h>
#include <stdlib.h>

static const char *manual[] = {
"BUDOSTACK C Programming Guide",
"======================================================================",
"Welcome! This tutorial is a compact C programming handbook tailored for",
"BUDOSTACK. It pairs theory with runnable examples so you can build and",
"ship small utilities confidently.",
"",
"Getting started",
"---------------",
"1. Build everything: make clean all",
"2. Run this guide:   utilities/chelp",
"3. Explore sources:  main.c, lib/, utilities/",
"4. Compile your app: cc -std=c11 -Wall -Wextra -Werror -Wpedantic \\",
"                     -I. -o myapp myapp.c",
"",
"Hello, world",
"------------",
"#include <stdio.h>",
"",
"int main(void) {",
"    printf(\"Hello, world\\n\");",
"    return 0;",
"}",
"",
"Core syntax",
"-----------",
"- Types: char, short, int, long, float, double, _Bool, void.",
"- Qualifiers: const prevents writes; volatile blocks unwanted caching.",
"- Control flow: if/else, switch, for, while, do/while, break, continue.",
"- Operators: == != < <= > >= && || ! + - * / % << >> & | ^ ~ ?: . ->",
"",
"Compilation model",
"-----------------",
"- The preprocessor expands #include, #define, and conditional blocks.",
"- The compiler turns translation units (.c + headers) into object files.",
"- The linker resolves symbols and produces executables or libraries.",
"- Headers declare interfaces; .c files define functions and storage.",
"",
"Headers and macros",
"------------------",
"- Include project headers before standard headers for consistent types.",
"- Use include guards (#ifndef FILE_H) or #pragma once in new headers.",
"- Prefer macros for compile-time constants; use inline/static for logic.",
"- Example: #define ARRAY_LEN(x) (sizeof(x) / sizeof((x)[0]))",
"",
"Variables and scope",
"-------------------",
"- File scope variables persist for the program lifetime. Mark them static",
"  unless shared.",
"- Block scope variables live until the block ends; always initialize them.",
"- Shadowing hides outer names; avoid it in new code for clarity.",
"",
"Functions",
"---------",
"- Declare prototypes before use to catch type mismatches early.",
"- Prefer static for helpers limited to one file to keep linkage private.",
"- Document ownership for pointers returned from functions.",
"- Example: size_t len(const char *s) { size_t i = 0; while (s[i])",
"  ++i; }",
"",
"Pointers",
"--------",
"- A pointer holds an address; *p dereferences, &x yields the address of x.",
"- Use size_t for lengths and ptrdiff_t for pointer differences.",
"- Always check for NULL before dereferencing dynamic pointers.",
"- Example: int value = 7; int *p = &value; printf(\"%d\\n\", *p);",
"",
"Arrays and strings",
"------------------",
"- char name[16] reserves 16 bytes; indices run from 0 to 15.",
"- Strings are null-terminated: ensure the last byte is '\\0'.",
"- Use snprintf to avoid overflow: snprintf(buf, sizeof buf, \"%s\", src);",
"- When passing arrays to functions, also pass their lengths explicitly.",
"",
"Structs and enums",
"-----------------",
"struct point { double x; double y; };",
"enum color { COLOR_RED, COLOR_GREEN, COLOR_BLUE };",
"- Use designated initializers: struct point p = { .x = 1.0, .y = 2.0 };",
"- Prefer enums for small sets of constants; they improve switch clarity.",
"",
"Dynamic memory",
"--------------",
"- malloc/calloc allocate; free releases. Always pair them.",
"- Check allocation results: ptr = malloc(n); if (!ptr) return EXIT_FAILURE;",
"- Avoid memory leaks by freeing before returning on errors.",
"- For arrays: int *a = calloc(count, sizeof *a); for (size_t i = 0;",
"  i < count; ++i) a[i] = (int)i;",
"",
"Input and output",
"----------------",
"- stdin, stdout, stderr are FILE pointers for console I/O.",
"- Use fgets for line input and check the return value for NULL.",
"- fprintf(stderr, ...) reports errors; fflush(stdout) flushes buffers.",
"- Example: if (fgets(buf, sizeof buf, stdin)) printf(\"%s\", buf);",
"",
"Files",
"-----",
"- FILE *f = fopen(path, \"r\"); if (!f) { perror(\"open\"); return 1; }",
"- fread/fwrite handle binary blocks; fprintf/fscanf handle text.",
"- Always fclose files you open, even on errors.",
"",
"Command line arguments",
"----------------------",
"int main(int argc, char **argv) {",
"    for (int i = 0; i < argc; ++i) printf(\"arg %d: %s\\n\", i, argv[i]);",
"    return 0;",
"}",
"- argc counts arguments; argv stores them as strings ending with NULL.",
"",
"Error handling",
"--------------",
"- Return EXIT_SUCCESS or EXIT_FAILURE from main for clarity.",
"- Use perror for syscalls and strerror(errno) for custom messages.",
"- Validate inputs aggressively to avoid undefined behavior.",
"",
"Pointers to functions",
"---------------------",
"- int (*op)(int, int) = add; allows passing functions as arguments.",
"- Useful for callbacks, comparators (qsort), or strategy selection.",
"",
"Standard library highlights",
"---------------------------",
"- <string.h>: memcpy, memmove, memset, strcmp, strncmp, strstr.",
"- <ctype.h>: isalpha, isdigit, tolower, toupper for character checks.",
"- <stdlib.h>: malloc, free, qsort, rand, strtol, exit.",
"- <time.h>: time, localtime, struct tm for timestamps.",
"- <assert.h>: assert(condition) for debug-time checks.",
"",
"Memory safety tips",
"------------------",
"- Avoid pointer arithmetic unless necessary; prefer array indexing.",
"- Zero-initialize structs with = {0} to prevent garbage reads.",
"- Guard against integer overflow when computing buffer sizes.",
"",
"Const correctness",
"-----------------",
"- Use const for read-only parameters: void print(const char *s).",
"- Return const pointers when callers must not modify shared storage.",
"",
"Modular design",
"--------------",
"- Place shared helpers in lib/ and expose prototypes in matching headers.",
"- Keep each .c focused; avoid gigantic files that hide responsibilities.",
"- Document ownership rules in comments near function declarations.",
"",
"Testing",
"-------",
"- Add small self-tests guarded by #ifdef TEST when helpful.",
"- Validate edge cases: empty strings, zero lengths, extreme values.",
"- Use make clean all to ensure every translation unit compiles cleanly.",
"",
"Debugging",
"---------",
"- printf debugging: print variables with clear labels and formats.",
"- Use -g with cc for debug symbols and run gdb ./yourprog.",
"- In gdb: run, bt, frame N, print var, continue, quit.",
"- AddressSanitizer is available on many systems: add -fsanitize=address.",
"",
"Style notes",
"-----------",
"- Indent with 4 spaces; braces follow K&R style used across BUDOSTACK.",
"- Keep lines within 78 columns for comfortable terminal paging.",
"- Comment non-obvious behaviour; avoid redundant comments.",
"",
"Practical exercise: file copier",
"-------------------------------",
"#include <errno.h>",
"#include <stdio.h>",
"#include <stdlib.h>",
"",
"int copy(const char *src, const char *dst) {",
"    char buf[4096];",
"    FILE *in = fopen(src, \"rb\");",
"    FILE *out = NULL;",
"",
"    if (!in) {",
"        perror(\"open src\");",
"        return -1;",
"    }",
"",
"    out = fopen(dst, \"wb\");",
"    if (!out) {",
"        perror(\"open dst\");",
"        fclose(in);",
"        return -1;",
"    }",
"",
"    for (;;) {",
"        size_t n = fread(buf, 1, sizeof buf, in);",
"        if (n && fwrite(buf, 1, n, out) != n) {",
"            perror(\"write\");",
"            break;",
"        }",
"        if (n < sizeof buf) {",
"            if (ferror(in)) perror(\"read\");",
"            break;",
"        }",
"    }",
"",
"    fclose(out);",
"    fclose(in);",
"    return 0;",
"}",
"",
"int main(int argc, char **argv) {",
"    if (argc != 3) {",
"        fprintf(stderr, \"usage: copy <src> <dst>\\n\");",
"        return EXIT_FAILURE;",
"    }",
"    return copy(argv[1], argv[2]) == 0 ? EXIT_SUCCESS : EXIT_FAILURE;",
"}",
"",
"What to study next",
"------------------",
"- Makefiles: targets, variables, pattern rules, and phony targets.",
"- Libraries: build static archives with ar rcs libutil.a *.o.",
"- Networking: BSD sockets (socket, bind, listen, accept, send, recv).",
"- Concurrency: POSIX threads (pthread_create, mutexes, condition vars).",
"- Data structures: linked lists, hash tables, dynamic arrays, ring buffers.",
"",
"Reading list",
"------------",
"- The C Programming Language (Kernighan and Ritchie).",
"- C Programming: A Modern Approach (King).",
"- POSIX.1-2008 manuals for system interfaces.",
"",
"Career pointers",
"---------------",
"- Build a portfolio: small utilities, tests, and documentation in git.",
"- Practice code reviews: explain choices and name trade-offs explicitly.",
"- Learn to profile: perf, valgrind, and compiler -pg instrumentation.",
"- Stay curious: read code in BUDOSTACK apps/ and games/ for patterns.",
"",
"Cheat sheet: formats",
"--------------------",
"- printf formats: %d int, %u unsigned, %ld long, %zu size_t, %p pointer.",
"- scanf formats:  %d int, %u unsigned, %ld long, %zu size_t, %p pointer.",
"- Remember to match argument types exactly with the chosen format.",
"",
"Checklist before shipping",
"-------------------------",
"- Run make clean all and ensure zero warnings.",
"- Test happy paths and error paths with realistic input.",
"- Free allocations and close files before returning.",
"- Keep outputs concise and helpful for command-line users.",
"",
"You now have a working pocket guide. Explore, modify, and build boldly!"
};

static void print_manual(void)
{
    const size_t lines = sizeof(manual) / sizeof(manual[0]);

    for (size_t i = 0; i < lines; ++i) {
        puts(manual[i]);
    }
}

int main(void)
{
    print_manual();
    return EXIT_SUCCESS;
}
